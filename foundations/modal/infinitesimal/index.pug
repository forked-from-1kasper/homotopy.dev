include ../../../header

html
    head
        meta(property='og:title'       content='INFINITESIMAL')
        meta(property='og:description' content='Infinitesimal Shape Modality (de Rham stack).')
        meta(property='og:url'         content='https://homotopy.dev/foundations/modal/infintesimal/')

block title
    title INFINITESIMAL

block content
    nav
        <a href='https://homotopy.dev/'>HTS</a>
        <a href='https://homotopy.dev/library/'>LIB</a>
        <a href='#'>INFINITESIMAL</a>
    article.main
        .exe
            section
                h1 INFINITESIMAL MODALITY

        aside <a href="https://homotopy.dev/library/">Homotopy Library</a>
            time 15 JAN 2019
        .exe
            section

                +tex.
                    $\mathbf{Definition}$ (Infinitesimal Shape Modality or de Rham stack). The two maps
                    $Im∶ U \rightarrow U$ and $\iota_A ∶ A \rightarrow Im(A)$ are called <i>shape modality</i> if
                    i) $\iota_A$ is an equivalence, the type $A$ is then called coreduced.; ii)
                    identity types of coreduced types are coreduced; iii) if $B∶Im(A)\rightarrow U$
                    is a dependent type such that for all $a∶Im(A)$ the type $B(a)$ is coreduced,
                    then we can define a section of $B$ by induction. The $Im(A)$ is called de Rham space.

                +code.
                    Im : U -> U
                    ImUnit (A: U) : A -> Im A
                    isCoreduced (A:U): U = isEquiv A (Im A) (ImUnit A)
                    ImCoreduced (A:U): isCoreduced (Im A)
                    ImRecursion (A B: U) (c: isCoreduced B) (f: A -> B) : Im A -> B
                    ImInduction (A: U) (B: Im A -> U) (x: (a: Im A) -> isCoreduced (B a))
                                (y: (a: A) -> B (ImUnit A a)) : (a: Im A) -> B a
                br

                h1 ÉTALE MAP

                +tex.
                    $\mathbf{Definition}$ (Étale map). A map $f:A \rightarrow B$ is <i>formally étale</i>
                    if its naturality square is a pullback:

                +tex(true).
                    $$
                    \begin{array}{ccc}
                        A & \mapright{ι_A} & Im(A) \\
                        \mapdown{f} & \square & \mapdown{Im(f)} \\
                        B & \mapright{ι_B} & Im(B) \\
                    \end{array}
                    $$

                +tex.
                    with induced naturality equation:

                +tex(true).
                    $$
                        \eta_f(x) : Im(f(\iota_A(x))) = \iota_B(Im(f(x))).
                    $$

                +code.
                    ImApp (A B: U) (f: A -> B) : Im A -> Im B
                    ImNaturality (A B: U) (f: A -> B) : (a: A) ->
                      Path (Im B) ((ImUnit B) (f a)) ((ImApp A B f) (ImUnit A a))
                br.

                +code.
                    isÉtaleMap (A B: U) (f: A -> B): U
                      = isPullbackSq A iA B (Im B) x y w f h where
                      iA : U = Im A
                      iB : U = Im B
                      x: iA -> iB = ImApp  A B f
                      y:  B -> iB = ImUnit B
                      w:  A -> iA = ImUnit A
                      c1: A -> iB = o A iA iB x w
                      c2: A -> iB = o A B  iB y f
                      T2: U = (a:A) -> Path iB (c1 a) (c2 a)
                      h: T2 = \(a : A) -> &lt;i&gt; ImNaturality A B f a @ -i
                br.

                +code.
                    EtaleMap (A B: U): U
                      = (f: A -> B)
                      * isÉtaleMap A B f
                br.

                +tex.
                    $\mathbf{Definition}$ (Infinitesimal Close).
                    Let $x,y: A$, then we have a type which could be
                    read x is infinitesimally close to y and is given as:

                +tex(true).
                    $$
                        x \sim y =_{def} ι_A (x) = ι_B (y).
                    $$

                +code.
                    isInfinitesimalClose (X: U) (a x': X): U
                       = Path (Im X) (ImUnit X a) (ImUnit X x')
                br.

                h1 FORMAL DISK BUNDLE

                +tex.
                    $\mathbf{Definition}$ (Formal Disk).
                    Let $A$ be a type and $a:A$. The type $\mathbb{D}_a$
                    defined below in three equivalent ways is called
                    the formal disk at a:
                    i) $\mathbb{D}_a$ is the sum of all point infinitesimal close to a;

                +tex(true).
                    $$
                       \mathbb{D}_a =_{def} \sum_{x:A} x \sim a
                    $$

                +tex.
                    ii) $\mathbb{D}_a$ is a fiber of $ι_A$ at $ι_A(a)$;
                    iii) $\mathbb{D}_a$ is defined as a pullback square:

                +tex(true).
                    $$
                    \begin{array}{ccc}
                        \mathbb{D}_a & \mapright{} & 1 \\
                        \mapdown{} & \square & \mapdown{* \mapsto ι_A(a)} \\
                        A & \mapright{ι_A} & Im(A) \\
                    \end{array}
                    $$

                +code.
                    formalDisc (X: U) (a: X): U
                       = (x': X) * isInfinitesimalClose X a x'

                +tex.
                    $\mathbf{Definition}$ (Differential).
                    If $f: A \rightarrow B$ is a type, there is a dependent function

                +tex(true).
                    $$
                        df : \prod_{x:A} \mathbb{D}_x \rightarrow \mathbb{D}_{f(x)}
                    $$

                p.
                    defined as

                +tex(true).
                    $$
                       df_a =_{def} (x,ε) \mapsto (f(x),η^{−1}(x)•Im(f(ε))•η_f(x))
                    $$

                +code.
                    differential (X Y: U) (f: X -> Y) (x: X)
                      : formalDisc X x -> formalDisc Y (f x)

                +tex.
                    $\mathbf{Definition}$ (Formal Disk Bundle).
                    Let $A$ be a type. The type $T_\infty(A)$
                    defined in one of the equivalent ways below
                    is called the formal disk bundle of $A$:
                    i) $T_\infty(A)$ is the sum over all formal disks in A:

                +tex(true).
                    $$
                      T_\infty(A) =_{def} \sum_{x:A}\mathbb{D}_x
                    $$
                    ii) $T_\infty(A)$ is defined by pullback square:

                +tex(true).
                    $$
                    \begin{array}{ccc}
                        T_\infty(A) & \mapright{} & A \\
                        \mapdown{} & \square & \mapdown{ι_A} \\
                        A & \mapright{ι_A} & Im(A) \\
                    \end{array}
                    $$

                +code.
                    formalDiscBundle (A: U): U
                      = (a: A) * formalDisc A a

                +tex.
                    $\mathbf{Theorem}$ (Hennion).
                    The tangent complex of a derived algebraic stack $X$
                    is equivalently the (sheaf of modules of) sections
                    of the formal neighbourhood of the diagonal of $X$.
                    We may think of $T_\infty(X)$ as being the tangent complex of $X$.

                +tex.
                    $\mathbf{Theorem}$ (Kock). The infinitesimal disk bundle construction is
                    left adjoint to the jet comonad:

                +tex(true).
                    $$
                        T_\infty \vdash Jet
                    $$

                +tex.
                    $\mathbf{Definition}$ (Induced map).
                    For a map $f : A \rightarrow B$ there is an
                    induced map on the formal disk bundles, given as
                    $$
                        T_\infty(A) =_{def} (a,ε) \mapsto (f(a),df_a(ε))
                    $$

                h1 MANIFOLDS

                +tex.
                    $\mathbf{Definition}$ (Homogeneous structure).
                    A type $A$ is homogeneous, if there are terms of the following types:
                    i) $e:A$; ii) $t: \prod_{x:A} A = A$; iii) $p: \prod_{x:A}t_x(e) = x$.

                +code.
                    homogeneous (A: U): U
                      = (e: A)
                      * (translationsFamily: (x: A) -> Path U A A)
                      * ((x: A) -> Path A (transport (translationsFamily x) e) x)
                br.

                h1 LITERATURE
                p.
                    [1]. Felix Wellen. <a href="http://www.andrew.cmu.edu/user/fwellen/cartan-draft.pdf">Cartan
                    Geometry in Modal Homotopy Type Theory</a><br>

include ../../../footer.pug
